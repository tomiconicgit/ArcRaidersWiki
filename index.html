<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Lens</title>
  <style>
    :root{
      --bg:#05070b;
      --glass:rgba(12,16,24,.55);
      --line:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --accent:rgba(124,240,255,.95);
      --good:rgba(182,255,122,.95);
      --shadow: 0 18px 44px rgba(0,0,0,.45);
      --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    body{overflow:hidden}

    .stage{position:fixed; inset:0; background:#000;}
    video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover; background:#000;
    }
    canvas{
      position:absolute; inset:0; width:100%; height:100%;
      pointer-events:none;
    }

    /* Floating labels */
    #labels{ position:absolute; inset:0; pointer-events:none; }
    .label{
      position:absolute;
      transform: translate(-50%, -120%);
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(10,14,22,.45);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 20px rgba(0,0,0,.25);
      font-weight: 700;
      font-size: 12px;
      letter-spacing: .2px;
      color: var(--text);
      opacity: 0;
      transition: opacity .22s ease, transform .22s ease;
      white-space: nowrap;
    }
    .label.on{
      opacity: 1;
      transform: translate(-50%, -135%);
    }
    .label .sub{
      display:block;
      font-weight: 600;
      font-size: 11px;
      color: var(--muted);
      margin-top:2px;
    }

    /* UI */
    header{
      position:absolute;
      left: max(12px, env(safe-area-inset-left));
      right:max(12px, env(safe-area-inset-right));
      top:  max(12px, env(safe-area-inset-top));
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding: 10px 12px;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,20,28,.72), rgba(16,20,28,.40));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .title{font-weight:800; font-size:13px;}
    .status{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .dot{width:10px;height:10px;border-radius:99px;background:rgba(255,255,255,.18);box-shadow:0 0 0 4px rgba(255,255,255,.06);}
    .dot.on{background:var(--good); box-shadow:0 0 0 4px rgba(182,255,122,.14), 0 0 18px rgba(182,255,122,.35);}

    .bar{
      position:absolute;
      left: max(12px, env(safe-area-inset-left));
      right:max(12px, env(safe-area-inset-right));
      bottom:max(12px, env(safe-area-inset-bottom));
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      padding: 10px;
      border-radius: var(--radius);
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(16,20,28,.72), rgba(16,20,28,.40));
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 14px;
      padding: 12px 12px;
      font-weight: 800;
      font-size: 13px;
      letter-spacing:.2px;
      -webkit-tap-highlight-color: transparent;
      user-select:none;
    }
    button:active{transform: translateY(1px); filter: brightness(1.08);}
    button.primary{border-color: rgba(124,240,255,.35); background: rgba(124,240,255,.12);}
    button.off{opacity:.65}
    .hint{
      position:absolute;
      left: max(12px, env(safe-area-inset-left));
      right:max(12px, env(safe-area-inset-right));
      top: calc(max(12px, env(safe-area-inset-top)) + 62px);
      padding: 10px 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(10,14,22,.35);
      backdrop-filter: blur(10px);
      font-size:12px;
      color: var(--muted);
      box-shadow: 0 14px 30px rgba(0,0,0,.25);
    }
    .hint b{color: var(--text);}

    /* Reduce motion fallback */
    @media (prefers-reduced-motion: reduce){
      .label{transition:none}
    }
  </style>

  <!-- TFJS + COCO-SSD (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div class="stage">
    <video id="video" playsinline muted></video>
    <canvas id="boxes"></canvas>
    <div id="labels"></div>

    <header>
      <div>
        <div class="title">Lens</div>
        <div class="status" id="status">Tap Start. First run loads the model.</div>
      </div>
      <div class="dot" id="dot" aria-hidden="true"></div>
    </header>

    <div class="hint" id="hint">
      <b>Live labels:</b> This demo recognizes common objects (e.g., bottle, phone).
      For brand labels like “Red Bull can”, you’ll add a custom model.
    </div>

    <div class="bar">
      <button id="start" class="primary">Start</button>
      <button id="toggle" class="off">Labels: On</button>
    </div>
  </div>

<script>
(() => {
  const video = document.getElementById("video");
  const canvas = document.getElementById("boxes");
  const ctx = canvas.getContext("2d");
  const labelsLayer = document.getElementById("labels");
  const statusEl = document.getElementById("status");
  const dot = document.getElementById("dot");
  const startBtn = document.getElementById("start");
  const toggleBtn = document.getElementById("toggle");

  let stream = null;
  let model = null;
  let running = false;
  let showLabels = true;

  // Label lifecycle manager (fade out if not seen)
  const labelMap = new Map(); // key -> {el, lastSeen}

  function setStatus(t){ statusEl.textContent = t; }
  function setDot(on){ dot.classList.toggle("on", !!on); }

  function resizeCanvasToVideo(){
    const r = video.getBoundingClientRect();
    canvas.width  = Math.max(1, Math.floor(r.width  * devicePixelRatio));
    canvas.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
  }
  window.addEventListener("resize", resizeCanvasToVideo);

  function clearOverlay(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }

  function drawBox(x,y,w,h, good=false){
    const dpr = devicePixelRatio || 1;
    ctx.save();
    ctx.lineWidth = 2.2 * dpr;
    ctx.strokeStyle = good ? "rgba(182,255,122,0.95)" : "rgba(124,240,255,0.95)";
    ctx.shadowColor = good ? "rgba(182,255,122,0.45)" : "rgba(124,240,255,0.45)";
    ctx.shadowBlur = 18 * dpr;
    roundRect(ctx, x,y,w,h, 14*dpr);
    ctx.stroke();
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function upsertLabel(key, text, sub, px, py){
    let item = labelMap.get(key);
    if(!item){
      const el = document.createElement("div");
      el.className = "label";
      el.innerHTML = `${text}<span class="sub">${sub}</span>`;
      labelsLayer.appendChild(el);
      item = { el, lastSeen: performance.now() };
      labelMap.set(key, item);
      requestAnimationFrame(() => el.classList.add("on"));
    }
    item.lastSeen = performance.now();

    // place
    item.el.style.left = `${px}px`;
    item.el.style.top  = `${py}px`;

    // update text (if changed)
    const cur = item.el.firstChild?.textContent || "";
    if(cur !== text){
      item.el.innerHTML = `${text}<span class="sub">${sub}</span>`;
    }

    // show/hide based on toggle
    item.el.style.display = showLabels ? "block" : "none";
  }

  function cleanupLabels(){
    const t = performance.now();
    for(const [key, item] of labelMap){
      if(t - item.lastSeen > 550){ // ms unseen -> fade
        item.el.classList.remove("on");
      }
      if(t - item.lastSeen > 1100){ // remove
        item.el.remove();
        labelMap.delete(key);
      }
    }
  }

  async function startCamera(){
    if(running) return;

    setStatus("Requesting camera…");
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{
          facingMode:{ ideal:"environment" },
          width:{ ideal:1920 },
          height:{ ideal:1080 }
        }
      });
    }catch(e){
      setStatus("Camera blocked. Check Safari permissions for this site.");
      return;
    }

    video.srcObject = stream;
    await video.play().catch(()=>{});
    setDot(true);

    // Fit overlay to screen size
    resizeCanvasToVideo();

    setStatus("Loading vision model… (first load can take a moment)");
    // TFJS backend: let it pick best; you can force webgl if you want
    // await tf.setBackend("webgl"); await tf.ready();
    model = await cocoSsd.load();

    setStatus("Live • looking for objects…");
    running = true;
    loop();
  }

  function stopCamera(){
    running = false;
    setDot(false);
    if(stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    clearOverlay();
    for(const [, item] of labelMap){ item.el.remove(); }
    labelMap.clear();
    setStatus("Stopped.");
  }

  // Main detection loop (throttled)
  let lastInfer = 0;
  const INFER_EVERY_MS = 180; // tweak for performance vs responsiveness

  async function loop(){
    if(!running) return;

    // draw + infer every N ms
    const now = performance.now();
    if(now - lastInfer >= INFER_EVERY_MS && model && video.videoWidth){
      lastInfer = now;

      // Clear overlay
      clearOverlay();

      const rect = video.getBoundingClientRect();
      const W = canvas.width, H = canvas.height;

      // Get predictions
      const preds = await model.detect(video);

      // Keep top detections
      const top = preds
        .filter(p => p.score >= 0.55)
        .sort((a,b)=>b.score-a.score)
        .slice(0, 6);

      for(const p of top){
        const [bx, by, bw, bh] = p.bbox; // in CSS pixels relative to video element draw area
        // Convert CSS pixel bbox -> canvas pixels (dpr-scaled)
        const sx = (bx / rect.width) * W;
        const sy = (by / rect.height) * H;
        const sw = (bw / rect.width) * W;
        const sh = (bh / rect.height) * H;

        drawBox(sx, sy, sw, sh, p.score > 0.75);

        const labelX = (sx + sw/2) / devicePixelRatio;
        const labelY = (sy) / devicePixelRatio;

        // A stable-ish key: class name + rough position bucket
        const key = `${p.class}-${Math.round(labelX/40)}-${Math.round(labelY/40)}`;
        const nice = prettify(p.class);

        // NOTE: Brand-specific names like "Red Bull" won't appear here without a custom model.
        upsertLabel(
          key,
          nice,
          `${Math.round(p.score*100)}%`,
          labelX,
          labelY
        );
      }

      cleanupLabels();
    }

    requestAnimationFrame(loop);
  }

  function prettify(name){
    const map = {
      "cell phone":"Phone",
      "sports ball":"Ball",
      "remote":"Remote",
      "tv":"TV",
      "bottle":"Bottle",
      "cup":"Cup",
      "knife":"Knife",
      "scissors":"Scissors",
      "book":"Book",
      "laptop":"Laptop",
      "keyboard":"Keyboard"
    };
    return map[name] || (name.charAt(0).toUpperCase() + name.slice(1));
  }

  // UI
  startBtn.addEventListener("click", async () => {
    if(!running){
      startBtn.textContent = "Stop";
      await startCamera();
      if(!running) startBtn.textContent = "Start";
    }else{
      startBtn.textContent = "Start";
      stopCamera();
    }
  });

  toggleBtn.addEventListener("click", () => {
    showLabels = !showLabels;
    toggleBtn.textContent = `Labels: ${showLabels ? "On" : "Off"}`;
    toggleBtn.classList.toggle("off", !showLabels);
    for(const [, item] of labelMap){
      item.el.style.display = showLabels ? "block" : "none";
    }
  });

})();
</script>
</body>
</html>