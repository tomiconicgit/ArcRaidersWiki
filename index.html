<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spatial OS - Web Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, sans-serif; }
        #webcam { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: -1; transform: scaleX(-1); }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .hud-hint { position: fixed; top: 20px; width: 100%; text-align: center; color: #00f3ff; text-shadow: 0 0 10px #00f3ff; z-index: 10; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>
    <div class="hud-hint">PINCH TO GRAB & MOVE WIDGETS</div>
    <video id="webcam" autoplay playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // --- 1. SET UP THE 3D WORLD ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. CREATE DASHBOARD TILES ---
        const tiles = [];
        const createTile = (color, x, name) => {
            const geometry = new THREE.RoundedBoxGeometry ? new THREE.RoundedBoxGeometry(1, 1, 0.1, 10, 0.1) : new THREE.BoxGeometry(1, 1, 0.1);
            const material = new THREE.MeshStandardMaterial({ color: color, transparent: true, opacity: 0.9, roughness: 0.2, metalness: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, -3);
            scene.add(mesh);
            tiles.push(mesh);
        };
        
        // Add lights for that premium iOS look
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0x00f3ff, 1);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        // Create 3 demo app tiles
        createTile(0x007AFF, -1.5, "Safari"); // iOS Blue
        createTile(0x34C759, 0, "Photos");   // iOS Green
        createTile(0xFF2D55, 1.5, "Music");  // iOS Pink

        // --- 3. HAND TRACKING AI (MediaPipe) ---
        let grabbedTile = null;
        const videoElement = document.getElementById('webcam');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                
                // Index finger tip (Landmark 8) and Thumb tip (Landmark 4)
                const index = hand[8];
                const thumb = hand[4];

                // Calculate distance for "Pinch" gesture
                const dist = Math.sqrt(Math.pow(index.x - thumb.x, 2) + Math.pow(index.y - thumb.y, 2));
                
                // Map hand coordinates to 3D space
                const x = (0.5 - index.x) * 10; // Inverted because camera is mirrored
                const y = (0.5 - index.y) * 5;

                if (dist < 0.05) { // If pinching
                    if (!grabbedTile) {
                        // Check which tile is closest to finger
                        tiles.forEach(tile => {
                            if (Math.abs(tile.position.x - x) < 0.8 && Math.abs(tile.position.y - y) < 0.8) {
                                grabbedTile = tile;
                            }
                        });
                    }
                    if (grabbedTile) {
                        grabbedTile.position.lerp(new THREE.Vector3(x, y, -3), 0.2);
                        grabbedTile.material.emissive.setHex(0x00f3ff);
                    }
                } else {
                    if (grabbedTile) grabbedTile.material.emissive.setHex(0x000000);
                    grabbedTile = null;
                }
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // --- 4. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            // Floating effect for tiles not being held
            tiles.forEach(tile => {
                if (tile !== grabbedTile) {
                    tile.position.y += Math.sin(Date.now() * 0.002) * 0.002;
                }
            });
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
